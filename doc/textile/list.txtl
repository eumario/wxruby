h1(#wxlist). Wx::List

List classes provide linked list functionality for Widgets, and for an
application if it wishes.  Depending on the form of constructor used, a list
can be keyed on integer or string keys to provide a primitive look-up ability,
but please note that this feature is *deprecated*.
See "HashMap":hashmap.html  for a faster method of storage
when random access is required.

While List class in the previous versions of Widgets only could contain
elements of type Object and had essentially untyped interface (thus allowing
you to put apples in the list and read back oranges from it), the new List
classes family may contain elements of any type and has much more strict type
checking. Unfortunately, it also requires an additional line to be inserted in
your program for each list class you use (which is the only solution short of
using templates which is not done in Widgets because of portability issues).

The general idea is to have the base class ListBase working with _void *_
data but make all of its dangerous (because untyped) functions protected, so
that they can only be used from derived classes which, in turn, expose a type
safe interface. With this approach a new List-like class must be defined for
each list type (i.e. list of ints, of Strings or of MyObjects). This is done
with _WX_DECLARE_LIST_ and _WX_DEFINE_LIST_ macros like this
(notice the similarity with WX_DECLARE_OBJARRAY and WX_IMPLEMENT_OBJARRAY
macros):

h2. Example


     // this part might be in a header or source (.cpp) file
     class MyListElement
     {
         ... // whatever
     };
 
     // declare our list class: this macro declares and partly implements MyList
     // class (which derives from ListBase)
     WX_DECLARE_LIST(MyListElement, MyList);
 
     ...
 
     // the only requirement for the rest is to be AFTER the full declaration of
     // MyListElement (for WX_DECLARE_LIST forward declaration is enough), but
     // usually it will be found in the source file and not in the header
 
     #include &lt;wx/listimpl.cpp&gt;
     WX_DEFINE_LIST(MyList);
 
     // now MyList class may be used as a usual List, but all of its methods
     // will take/return the objects of the right (i.e. MyListElement) type. You
     // also have MyList::Node type which is the type-safe version of Node.
     MyList list;
     MyListElement element;
     list.Append(element);      // ok
     list.Append(17);           // error: incorrect type
 
     // let's iterate over the list
     for ( MyList::Node *node = list.GetFirst(); node; node = node->GetNext() )
     {
         MyListElement *current = node->GetData();
 
         ...process the current element...
     }
 

For compatibility with previous versions List and StringList classes are
still defined, but their usage is deprecated and they will disappear in the
future versions completely. The use of the latter is especially discouraged as
it is not only unsafe but is also much less efficient than 
"ArrayString":arraystring.html class.

In the documentation of the list classes below, the template notations are
used even though these classes are not really templates at all -- but it helps
to think about them as if they were. You should replace Node<T> with
ListName::Node and T itself with the list element type (i.e. the first
parameter of WX_DECLARE_LIST).

h2. Derived from

"Object":object.html

h2. Example

It is very common to iterate on a list as follows:


   ...
   Window *win1 = new Window(...);
   Window *win2 = new Window(...);
 
   List SomeList;
   SomeList.Append(win1);
   SomeList.Append(win2);
 
   ...
 
   Node *node = SomeList.GetFirst();
   while (node)
   {
     Window *win = node->GetData();
     ...
     node = node->GetNext();
   }
 

To delete nodes in a list as the list is being traversed, replace


     ...
     node = node->GetNext();
     ...
 

with


     ...
     delete win;
     delete node;
     node = SomeList.GetFirst();
     ...
 

See "Node":node.html for members that retrieve the data associated with a node, and
members for getting to the next or previous node.

h2. See also

"Node":node.html,
"Array":array.html

<div id="methods">

h2. Methods

* "List.new":#List_new
* "List#append":#List_append
* "List#clear":#List_clear
* "List#delete_contents":#List_deletecontents
* "List#delete_node":#List_deletenode
* "List#delete_object":#List_deleteobject
* "List#erase":#List_erase
* "List#find":#List_find
* "List#get_count":#List_getcount
* "List#get_first":#List_getfirst
* "List#get_last":#List_getlast
* "List#index_of":#List_indexof
* "List#insert":#List_insert
* "List#is_empty":#List_isempty
* "List#item":#List_item
* "List#member":#List_member
* "List#nth":#List_nth
* "List#number":#List_number
* "List#sort":#List_sort

</div>


h3(#List_new). List.new

  *List.new*(%(arg-type)Integer% n,  %(arg-type)T% objects[])

  *List.new*(%(arg-type)T% object,  ...)

*Note*: keyed lists are deprecated and should not be used in new code.

  *List.new*(%(arg-type)unsigned int% key_type)

Constructors. _key_type_ is one of KEY_NONE, KEY_INTEGER, or KEY_STRING,
and indicates what sort of keying is required (if any).

_objects_ is an array of _n_ objects with which to initialize the list.

The variable-length argument list constructor must be supplied with a
terminating NULL.

  *destructor*()

Destroys the list.  Also destroys any remaining nodes, but does not destroy
client data held in the nodes.

h3(#List_append). List#append

 "Node<T>":node<t>.html *append*(%(arg-type)T% object)

*Note*: keyed lists are deprecated and should not be used in new code.

 "Node<T>":node<t>.html *append*(%(arg-type)Integer% key,  %(arg-type)T% object)

 "Node<T>":node<t>.html *append*(%(arg-type)String% key,  %(arg-type)T% object)

Appends a new "Node":node.html to the end of the list and puts a
pointer to the 