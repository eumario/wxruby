h1. Event handling overview

This page explains how to listen for and respond to to user interaction
events. Events include pressing a key, clicking a button, moving the
mouse, resizing a window and so on. Actions that an application carries
out when the event occurs are called *event handlers*.

The basic way to set up an event handler in WxRuby is to call a method
named evt_xxx (where xxx is the type of event that should be handled),
and pass it a block that should be run when the event occurs. For
example:

 evt_size { puts "I was resized" }

When an event occurs, an event object is created containing information
about the event, such as where on the screen it took place, or what key
was pressed. To access this information within an event handler, simply
pass a block that accepts a single argument:

 evt_size { | event | puts "Width now " + event.get_size.get_width.to_s }

The event object will be of the appropriate class for the type of event
being handled - for example, a "SizeEvent":sizeevent.html for a evt_size
handler, or a "TreeEvent":treeevent.html from a TreeCtrl. All the event
classes are listed "on the home page":/#events . 

Typically, it's easier to organise more complex event handlers into
methods, called via the block:

 def initialize
   ..
   evt_size { | event | on_size(event) }
 end

 def on_size(event)
   ...
 end

h2. A few more details about event handlers

Setting up event handlers is simple, but not *quite* that simple. The
way they are defined and passed between windows varies a little between
two groups. The first is CommandEvents, which are generated by user
interaction with controls. The second includes all other events. 

h3. Command events

"CommandEvents":commandevent.html are generated by user interface
controls such as buttons, text boxes, radio buttons, lists and so
on. They include information about the event - such as the new state of
the control (such as the new selection from a list). 

These sort of events 'bubble' up to parent windows, so parent windows
can set up handlers to listen to events generated by child
controls. This also means that you have to explicitly tell WxRuby the
source of events you want to handle events from. This is done by passing
an @id@ argument to the evt_xxx method, containing the Wx id of the
control you want events from.

 my_button = Wx::Button.new(panel, 1001, 'Press me')
 evt_button(1001) { 'my_button was pressed' }

Note this doesn't mean you have to define the ids in advance - you can
let WxRuby generate an id for you, then call the @get_id@ method to get
the id for the event handler.

 my_button = Wx::Button.new(panel, -1, 'Press me')
 evt_button( my_button.get_id ) { 'my_button was pressed' }

h3. Other events

Other events in WxRuby include sizing, activating, closing and moving
windows, changing layouts with splitters and sashes, and moving through
multi-pane organisers like Wizards and Notebooks. All these kind of
events are *only visible to the window itself*. They are not visible to
parent windows. The practical effect of this is that the evt_xxx method
must be called on @self@, and no @id@ parameter is needed.

 evt_size { "I was resized" }

h2. Vetoing and skipping events

Sometimes a given event should not be permitted. For example, a user has
tried to close a dialog, but there is an invalid value in a text box, so
the dialog should not be closed. The action can be blocked by calling
the "veto":event.html#Event_veto method:

 if not ready
   event.veto
 end

Sometimes you want the opposite - to ensure that the event's original
aim is completed, or passed on upwards to a parent window for
handling. In this case, the "skip":event.html#Event_skip method should
be called.

 event.skip

